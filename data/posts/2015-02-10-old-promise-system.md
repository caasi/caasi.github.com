> Broken promises by the way actually have two varieties of broken, there is directly and indirectly broken. In the case where the operation X raised an exception then you have a directly broken promise, and with a directly broken promise you can inquire about the exception that caused it to be broken, and that is the problem. You can ask what was the problem? Why did you break your promise to me? An indirectly broken promise results from making a request where either the recipient of the request or one of the arguments of the request was itself a broken promise, because what can happen here is that I've got this int value back now what I can do with this int value is I can now make a further request of the int value, so I can take two int values and add them together and get a new int value, but it turns out that if the original x message results in a broken promise then this int value becomes a broken promise and therefore there is no integer back over here for me to ask to be added to another integer. So broken promises are never really represented by objects at all on the server, it's the comm layer that either one side of the wire or the other depending on how much information exists locally or not, can tell that this request involves a broken promise and therefore the promise that results from the broken request is indirectly broken and the broken promise that caused this guy to be indirectly broken is this guys excuse. Why did you break your promise to me? Oh don't blame me, it's his fault! And then you can track down the excuse chain to find the directly broken promises problem. You can have a chain of indirectly broken promises and that chain always has to end in a directly broken promise that has a problem.

> ...it turns out that the major benefit of the promise system was not with respect to network latency, it was with respect interactive performance in the context of server latency...

> If we use the garbage collector instead of ref counts over here then there would be no good guarantee about when you would find out that you didn't need f, and therefore there would be a delay before you could tell the server that you didn't it, and that would probably be a sufficient delay to ruin the effect.

> I would be surprised if it took more than two man weeks to get the thing working and would be surprised if that the vast majority of that were not just the details of the TCP/IP system. As far as the rest of the promise system is concerned, I would be surprised if it took as much as a week.
